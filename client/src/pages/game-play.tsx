import { useEffect, useState, useRef } from 'react';
import { useLocation } from 'wouter';
import { useQuery } from '@tanstack/react-query';
import { useWebSocket } from '@/hooks/use-websocket';
import { getCurrentUser } from '@/lib/user-utils';
import { gameManager, type GameChoice } from '@/lib/game-manager';
import type { RoomWithPlayers, GameState, User } from '@shared/schema';
import type { NumberGuessGameState } from '@shared/games/number-guessing/schema';
import type { OddEvenGameState } from '@shared/games/odd-even/schema';
import type { TicTacToeGameState } from '@shared/games/tic-tac-toe/schema';
import type { BluffCardGameState } from '@shared/games/bluff-card/schema';
import type { ChessGameState } from '@shared/games/chess/schema';
import { NumberGuessingGame } from '@/components/game-play/number-guessing/NumberGuessingGame';
import { OddEvenGame } from '@/components/game-play/odd-even/OddEvenGame';
import { TicTacToeGame } from '@/components/game-play/tic-tac-toe/TicTacToeGame';
import { BluffCardGame } from '@/components/game-play/bluff-card/BluffCardGame';
import { ChessGame } from '@/components/game-play/chess/ChessGame';
import { GameLoading } from '@/components/game-play/common/game-loading';
import { GameHeader } from '@/components/game-play/common/game-header';
import { PlayersStatus } from '@/components/game-play/common/players-status';

interface GamePlayPageProps {
  roomId: string;
}

export default function GamePlayPage({ roomId }: GamePlayPageProps) {
  const [, setLocation] = useLocation();
  const currentUser = getCurrentUser();
  const [gameState, setGameState] = useState<GameState | null>(null);

  const [selectedChoice, setSelectedChoice] = useState<GameChoice | null>(null);
  const [moveSubmitted, setMoveSubmitted] = useState(false);

  // WebSocket Ìï®ÏàòÎì§Ïùò ÏïàÏ†ïÏ†ÅÏù∏ Ï∞∏Ï°∞Î•º ÏúÑÌïú ref
  const disconnectRef = useRef<((permanent?: boolean) => void) | null>(null);
  const connectRef = useRef<(() => void) | null>(null);

  const { data: room } = useQuery<RoomWithPlayers>({
    queryKey: ['/api/rooms', roomId],
    enabled: !!roomId,
  });

  const { data: gameData } = useQuery<GameState>({
    queryKey: ['/api/games', roomId],
    enabled: !!roomId,
  });

  const { sendMessage, isConnected, disconnect, connect } = useWebSocket('/ws', {
    reconnect: true, // Ïû¨Ïó∞Í≤∞ ÌôúÏÑ±Ìôî
    onMessage: (message: any) => {
      console.log('üì® WebSocket Î©îÏãúÏßÄ ÏàòÏã†:', message.type, message.data);
      
      switch (message.type) {
        case 'game_start':
          if (message.data?.gameState) {
            setGameState(message.data.gameState);
          }
          break;
        case 'game_state':
          console.log('üîÑ Í≤åÏûÑ ÏÉÅÌÉú ÏàòÏã†:', message.data);
          console.log('üìä Ïó∞Í≤∞ Ìï¥Ï†úÎêú ÌîåÎ†àÏù¥Ïñ¥:', message.data?.disconnectedPlayers || []);
          setGameState(message.data);
          setMoveSubmitted(false);
          break;
        case 'game_update': // Ïù¥ ÏºÄÏù¥Ïä§ Ï∂îÍ∞Ä!
          console.log('üîÑ Í≤åÏûÑ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏:', message.data);
          console.log('üìä Ïó∞Í≤∞ Ìï¥Ï†úÎêú ÌîåÎ†àÏù¥Ïñ¥:', message.data?.disconnectedPlayers || []);
          setGameState(message.data);
          setMoveSubmitted(false);
          break;
        case 'round_result':
          setGameState(message.data);
          setSelectedChoice(null);
          setMoveSubmitted(false);
          break;
        case 'game_end':
          setGameState(message.data);
          break;
        case 'player_left':
          console.log('üë§ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎÇòÍ∞ê:', message.data);
          // Í≤åÏûÑ ÏÉÅÌÉúÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÎ©¥ ÏûêÎèôÏúºÎ°ú Î∞òÏòÅÎê®
          // Ïó∞Í≤∞ Ìï¥Ï†úÏù∏ Í≤ΩÏö∞ Ï∂îÍ∞Ä Ï≤òÎ¶¨
          if (message.data?.reason === 'disconnected') {
            console.log('üîå ÌîåÎ†àÏù¥Ïñ¥ Ïó∞Í≤∞ Ìï¥Ï†ú:', message.data);
          }
          break;
        case 'player_reconnected':
          console.log('üîÑ ÌîåÎ†àÏù¥Ïñ¥ Ïû¨Ïó∞Í≤∞:', message.data);
          // Í≤åÏûÑ ÏÉÅÌÉúÍ∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÎ©¥ ÏûêÎèôÏúºÎ°ú Î∞òÏòÅÎê®
          break;
      }
    },
    onOpen: () => {
      if (currentUser) {
        sendMessage({
          type: 'associate_user',
          data: { userId: currentUser.id }
        });
        
        // Ïû¨Ïó∞Í≤∞ Ïãú Î∞© Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏ≤≠
        if (roomId) {
          sendMessage({
            type: 'room_update',
            roomId: roomId,
            data: { roomId: roomId }
          });
        }
      }
    },
    onClose: () => {
      console.log('üîå WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú');
    },
    onError: (error) => {
      console.error('‚ùå WebSocket Ïò§Î•ò:', error);
    }
  });

  // WebSocket Ìï®Ïàò Ï∞∏Ï°∞ ÏóÖÎç∞Ïù¥Ìä∏
  useEffect(() => {
    disconnectRef.current = disconnect;
    connectRef.current = connect;
  }, [disconnect, connect]);

  useEffect(() => {
    if (!currentUser || !roomId) {
      setLocation('/');
      return;
    }
  }, [currentUser, roomId, setLocation]);

  // WebSocket Ïó∞Í≤∞ Í¥ÄÎ¶¨
  useEffect(() => {
    const handleBeforeUnload = () => {
      console.log('üéÆ ÌéòÏù¥ÏßÄ ÎÇòÍ∞ÄÍ∏∞ Í∞êÏßÄ - WebSocket Ïó∞Í≤∞ Ï†ïÎ¶¨');
      disconnectRef.current?.(true);
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      console.log('üéÆ Í≤åÏûÑ ÌéòÏù¥ÏßÄ Ïñ∏ÎßàÏö¥Ìä∏ - WebSocket Ïó∞Í≤∞ Ï†ïÎ¶¨');
      window.removeEventListener('beforeunload', handleBeforeUnload);
      disconnectRef.current?.(true);
    };
  }, []); // ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ ÏóÜÏùå - Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏/Ïñ∏ÎßàÏö¥Ìä∏ ÏãúÏóêÎßå Ïã§Ìñâ

  // ÌéòÏù¥ÏßÄ Ìè¨Ïª§Ïä§ Î≥µÍ∑Ä Ïãú Ïû¨Ïó∞Í≤∞ Ï≤òÎ¶¨Î•º Î≥ÑÎèÑ effectÎ°ú Î∂ÑÎ¶¨
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (!document.hidden && !isConnected) {
        console.log('üîÑ ÌéòÏù¥ÏßÄ Ìè¨Ïª§Ïä§ Î≥µÍ∑Ä - WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ');
        // ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
        setTimeout(() => {
          if (!isConnected) {
            connectRef.current?.();
          }
        }, 500);
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isConnected]); // isConnectedÎßå ÏùòÏ°¥ÏÑ±ÏúºÎ°ú Ïú†ÏßÄ

  // Í≤åÏûÑ ÌéòÏù¥ÏßÄÏóêÏÑú WebSocketÏóê Î∞© Ï†ïÎ≥¥ Ï†ÑÏÜ°
  useEffect(() => {
    if (isConnected && currentUser && roomId) {
      sendMessage({
        type: 'room_update',
        roomId: roomId,
        data: { roomId: roomId }
      });
    }
  }, [isConnected, currentUser, roomId, sendMessage]);

  // Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞Í∞Ä Î°úÎìúÎêòÎ©¥ Í≤åÏûÑ ÏÉÅÌÉú ÏÑ§Ï†ï
  useEffect(() => {
    if (gameData) {
      setGameState(gameData);
    }
  }, [gameData]);



  const handleChoiceSelection = (choice: GameChoice) => {
    if (moveSubmitted || !gameState || gameState.gameStatus !== 'waiting_for_moves' || !isParticipant) return;
    
    // Í≤åÏûÑ Îß§ÎãàÏ†ÄÎ•º ÌÜµÌï¥ ÏÑ†ÌÉùÏßÄ Í≤ÄÏ¶ù
    if (!gameManager.isValidChoice(gameState.gameType, choice)) {
      console.error('Invalid choice for game type:', gameState.gameType, choice);
      return;
    }
    
    setSelectedChoice(choice);
    setMoveSubmitted(true);
    
    // Í≤åÏûÑ Îß§ÎãàÏ†ÄÎ•º ÌÜµÌï¥ Î©îÏãúÏßÄ ÏÉùÏÑ±
    const choiceMessage = gameManager.createChoiceMessage(gameState.gameType, choice);
    if (!choiceMessage) {
      console.error('Failed to create choice message for game type:', gameState.gameType);
      return;
    }

    const metadata = gameManager.getGameMetadata(gameState.gameType);
    if (!metadata) {
      console.error('No metadata found for game type:', gameState.gameType);
      return;
    }

    sendMessage({
      type: metadata.messageType as any,
      roomId: roomId!,
      userId: currentUser!.id,
      data: gameState.gameType === 'number-guessing' 
        ? { number: choice } 
        : { choice: choice }
    });
  };

  const handleLeaveGame = () => {
    setLocation('/');
  };



  const getResultText = (result: string, isCurrentUser: boolean) => {
    if (result === 'draw') return 'Î¨¥ÏäπÎ∂Ä';
    if (isCurrentUser) {
      return result === 'win' ? 'ÏäπÎ¶¨!' : 'Ìå®Î∞∞';
    }
    return result === 'win' ? 'Ìå®Î∞∞' : 'ÏäπÎ¶¨!';
  };

  const renderGameComponent = () => {
    if (!gameState || !room) return null;

    const commonProps = {
      room,
      currentUser,
      isParticipant,
      moveSubmitted,
      onChoiceSelect: handleChoiceSelection,
      gamePlayers,
    };

    switch (gameState.gameType) {
      case 'number-guessing':
        return (
          <NumberGuessingGame
            {...commonProps}
            gameState={gameState as NumberGuessGameState}
            selectedChoice={selectedChoice as any}
          />
        );
      
      case 'odd-even':
        return (
          <OddEvenGame
            {...commonProps}
            gameState={gameState as OddEvenGameState}
            selectedChoice={selectedChoice as any}
          />
        );

      case 'tic-tac-toe':
        return (
          <TicTacToeGame
            gameState={gameState as TicTacToeGameState}
            onMoveSelect={(position) => {
              const metadata = gameManager.getGameMetadata('tic-tac-toe');
              if (metadata) {
                sendMessage({
                  type: metadata.messageType as any,
                  roomId,
                  userId: currentUser?.id,
                  data: { position }
                });
                setMoveSubmitted(true);
              }
            }}
            isParticipant={isParticipant}
            currentUser={currentUser}
            gamePlayers={gamePlayers}
          />
        );

      case 'bluff-card':
        return (
          <BluffCardGame
            gameState={gameState as BluffCardGameState}
            isParticipant={isParticipant}
            moveSubmitted={moveSubmitted}
            room={room}
            currentUser={currentUser}
            gamePlayers={gamePlayers}
            onMakeMove={(move) => {
              // ÌÑ¥ Í∏∞Î∞ò Í≤åÏûÑÏùÄ moveÎ•º ÏßÅÏ†ë Î©îÏãúÏßÄÎ°ú Ï†ÑÏÜ°
              const messageToSend = {
                type: move.type as any,
                roomId,
                userId: currentUser?.id,
                data: move
              };
              sendMessage(messageToSend);
              setMoveSubmitted(true);
            }}
            canMakeMove={!moveSubmitted && gameState.currentPlayer === currentUser?.id}
          />
        );

      case 'chess':
        return (
          <ChessGame
            gameState={gameState as ChessGameState}
            onMakeMove={(move) => {
              const metadata = gameManager.getGameMetadata('chess');
              if (metadata) {
                sendMessage({
                  type: metadata.messageType as any,
                  roomId,
                  userId: currentUser?.id,
                  data: { move }
                });
                setMoveSubmitted(true);
              }
            }}
            isParticipant={isParticipant}
            currentUser={currentUser}
            gamePlayers={gamePlayers}
            canMakeMove={!moveSubmitted && gameState.currentPlayer === currentUser?.id}
          />
        );
      
      default:
        return (
          <div className="text-center p-8">
            <p className="text-white">ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Í≤åÏûÑ ÌÉÄÏûÖÏûÖÎãàÎã§: {(gameState as any).gameType}</p>
          </div>
        );
    }
  };

  if (!room || !gameState) {
    return (
      <GameLoading 
        room={!!room} 
        gameState={!!gameState} 
      />
    );
  }

  const gamePlayers = room.players.filter(p => gameState.playerIds.includes(p.userId));
  const isParticipant = Boolean(currentUser?.id && gameState.playerIds.includes(currentUser.id));
  
  // ÎùºÏö¥Îìú Í∏∞Î∞ò Í≤åÏûÑÎßå Ï†êÏàò Í≥ÑÏÇ∞
  const isRoundBased = 'playerScores' in gameState;
  const currentPlayerScore = isRoundBased && currentUser?.id ? (gameState as any).playerScores[currentUser.id] || 0 : 0;

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
      <div className="max-w-4xl mx-auto">
        {/* Header */}
        <GameHeader 
          gameState={gameState}
          gamePlayers={gamePlayers}
          isParticipant={isParticipant}
          onLeaveGame={handleLeaveGame}
        />

        {/* Players Status - GameHeader ÏïÑÎûòÎ°ú Ïù¥Îèô */}
        <PlayersStatus 
          gamePlayers={gamePlayers}
          currentUser={currentUser}
          gameState={gameState}
        />

        {/* Game Content - Dynamically rendered based on game type */}
        {renderGameComponent()}
      </div>
    </div>
  );
}